<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tic Tac Toe (Eth OS Game) with Robot Opponent</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css"
  />
  <style>
    /* Background gradient and shapes inspired by https://ethos.vision/ */
    body {
      background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
      position: relative;
      min-height: 100vh;
      overflow-x: hidden;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 1rem;
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
        Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
    }
    /* Large blurred colored circles */
    .bg-shape-1, .bg-shape-2, .bg-shape-3 {
      position: fixed;
      border-radius: 50%;
      filter: blur(120px);
      opacity: 0.4;
      z-index: -1;
      pointer-events: none;
    }
    .bg-shape-1 {
      width: 400px;
      height: 400px;
      background: #3b82f6; /* blue-500 */
      top: -100px;
      left: -100px;
    }
    .bg-shape-2 {
      width: 500px;
      height: 500px;
      background: #ec4899; /* pink-500 */
      top: 200px;
      right: -150px;
    }
    .bg-shape-3 {
      width: 600px;
      height: 600px;
      background: #facc15; /* yellow-400 */
      bottom: -200px;
      left: 50%;
      transform: translateX(-50%);
    }

    /* Container styling */
    main {
      background: rgba(255 255 255 / 0.1);
      backdrop-filter: saturate(180%) blur(20px);
      box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
      border-radius: 1rem;
      border: 1px solid rgba(255 255 255 / 0.18);
      max-width: 400px;
      width: 100%;
      padding: 1.5rem 1.5rem 2rem;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    /* Cell styling */
    #board {
      border: 4px solid rgba(255 255 255 / 0.5);
      border-radius: 0.5rem;
      box-sizing: border-box;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 0;
      width: 100%;
      max-width: 360px;
    }
    .cell {
      aspect-ratio: 1 / 1;
      cursor: pointer;
      user-select: none;
      font-weight: 900;
      display: flex;
      justify-content: center;
      align-items: center;
      transition: background-color 0.3s ease;
      padding: 0;
      border: 2px solid rgba(255 255 255 / 0.4);
      box-sizing: border-box;
      position: relative;
    }
    .cell:focus {
      outline: none;
      box-shadow: 0 0 10px 3px #3b82f6;
      background-color: rgba(255 255 255 / 0.2);
      z-index: 1;
    }
    .cell:hover:not(:disabled) {
      background-color: rgba(255 255 255 / 0.15);
      box-shadow: 0 0 8px 2px rgba(59, 130, 246, 0.6);
      z-index: 1;
    }
    .cell img {
      max-width: 70%;
      max-height: 70%;
      object-fit: contain;
      pointer-events: none;
      user-select: none;
      border-radius: 0.375rem; /* rounded-md */
    }

    /* Winning cells glow */
    .bg-green-300 {
      background-color: #4ade80 !important; /* Tailwind green-400 */
      box-shadow: 0 0 15px 5px #4ade80 !important;
      color: #166534 !important; /* Tailwind green-900 */
      border-color: #4ade80 !important;
      z-index: 2;
    }

    /* Header styling */
    header {
      text-align: center;
      color: white;
      text-shadow: 0 0 6px rgba(0,0,0,0.6);
      margin-bottom: 1.5rem;
      max-width: 400px;
      width: 100%;
    }
    header h1 {
      font-weight: 800;
      font-size: 2.5rem;
      margin-bottom: 0.25rem;
      line-height: 1.1;
    }
    header p {
      font-size: 1.125rem;
      font-weight: 500;
      margin: 0;
    }

    /* Controls styling */
    .controls {
      margin-top: 1.5rem;
      width: 100%;
      max-width: 400px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      color: white;
    }
    .controls > div {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 0.5rem;
      width: 100%;
    }
    .controls button {
      flex-shrink: 0;
    }
    .controls label {
      font-weight: 600;
      user-select: none;
    }
    .controls select {
      border: 1.5px solid rgba(255 255 255 / 0.7);
      border-radius: 0.375rem;
      background: transparent;
      color: white;
      padding: 0.25rem 0.75rem;
      font-size: 1rem;
      cursor: pointer;
      transition: border-color 0.2s ease;
    }
    .controls select:focus {
      outline: none;
      border-color: #3b82f6;
      box-shadow: 0 0 6px 2px #3b82f6;
    }
    .controls button {
      background-color: rgba(59, 130, 246, 0.8);
      color: white;
      padding: 0.5rem 1.5rem;
      border-radius: 0.375rem;
      font-weight: 600;
      cursor: pointer;
      border: none;
      transition: background-color 0.3s ease;
    }
    .controls button:hover,
    .controls button:focus {
      background-color: #2563eb;
      outline: none;
      box-shadow: 0 0 8px 3px #2563eb;
    }

    /* Status text */
    #status {
      font-weight: 700;
      font-size: 1.125rem;
      color: white;
      text-shadow: 0 0 6px rgba(0,0,0,0.7);
      min-height: 1.5rem;
      margin-bottom: 0.75rem;
      text-align: center;
      width: 100%;
      max-width: 400px;
    }

    /* New: @Pamela_Bowy text above game */
    #author {
      font-weight: 900;
      font-size: 2rem;
      color: white;
      text-shadow: 0 0 8px rgba(0,0,0,0.8);
      margin-bottom: 1rem;
      user-select: none;
      text-align: center;
      max-width: 400px;
      width: 100%;
    }
  </style>
</head>
<body>
  <div class="bg-shape-1"></div>
  <div class="bg-shape-2"></div>
  <div class="bg-shape-3"></div>

  <header>
    <h1>Tic Tac Toe (Eth OS Game)</h1>
    <p>Player vs Robot (AI) take turns filling the boxes.</p>
  </header>

  <main>
    <div id="author">@Pamela_Bowy</div>

    <div id="status" aria-live="polite" aria-atomic="true"></div>

    <div
      id="board"
      role="grid"
      aria-label="Tic Tac Toe board"
    >
      <button class="cell" data-cell-index="0" aria-label="Cell 1" role="gridcell" tabindex="0" type="button"></button>
      <button class="cell" data-cell-index="1" aria-label="Cell 2" role="gridcell" tabindex="-1" type="button"></button>
      <button class="cell" data-cell-index="2" aria-label="Cell 3" role="gridcell" tabindex="-1" type="button"></button>
      <button class="cell" data-cell-index="3" aria-label="Cell 4" role="gridcell" tabindex="-1" type="button"></button>
      <button class="cell" data-cell-index="4" aria-label="Cell 5" role="gridcell" tabindex="-1" type="button"></button>
      <button class="cell" data-cell-index="5" aria-label="Cell 6" role="gridcell" tabindex="-1" type="button"></button>
      <button class="cell" data-cell-index="6" aria-label="Cell 7" role="gridcell" tabindex="-1" type="button"></button>
      <button class="cell" data-cell-index="7" aria-label="Cell 8" role="gridcell" tabindex="-1" type="button"></button>
      <button class="cell" data-cell-index="8" aria-label="Cell 9" role="gridcell" tabindex="-1" type="button"></button>
    </div>

    <div class="controls">
      <div>
        <button
          id="restartBtn"
          aria-label="Restart game"
          type="button"
        >
          Restart Game
        </button>
      </div>
      <div>
        <label for="modeSelect">Select Mode:</label>
        <select
          id="modeSelect"
          aria-label="Select game mode"
        >
          <option value="pvp">Player vs Player</option>
          <option value="pvc" selected>Player vs Robot</option>
        </select>
      </div>
    </div>
  </main>

  <script>
    (() => {
      const board = document.getElementById("board");
      const cells = Array.from(board.querySelectorAll(".cell"));
      const status = document.getElementById("status");
      const restartBtn = document.getElementById("restartBtn");
      const modeSelect = document.getElementById("modeSelect");

      // Image URLs for X and O
      const X_IMG_URL = "https://pbs.twimg.com/profile_images/1927690030455341057/pAFgpio-_400x400.jpg";
      const O_IMG_URL = "https://pbs.twimg.com/profile_images/1401703659721744387/kZXRWsUi_400x400.jpg";

      // Game state
      let boardState = Array(9).fill(null);
      let currentPlayer = "X";
      let gameActive = true;
      let mode = modeSelect.value; // "pvp" or "pvc"

      // Winning combinations
      const winningCombinations = [
        [0, 1, 2],
        [3, 4, 5],
        [6, 7, 8],
        [0, 3, 6],
        [1, 4, 7],
        [2, 5, 8],
        [0, 4, 8],
        [2, 4, 6],
      ];

      // Update status text
      function updateStatus() {
        if (!gameActive) return;
        if (mode === "pvp") {
          status.textContent = `Player Turn: ${currentPlayer}`;
        } else {
          if (currentPlayer === "X") {
            status.textContent = "Player's Turn (X)";
          } else {
            status.textContent = "Robot's Turn (O)";
          }
        }
      }

      // Check for win or draw
      function checkResult() {
        for (const combo of winningCombinations) {
          const [a, b, c] = combo;
          if (
            boardState[a] &&
            boardState[a] === boardState[b] &&
            boardState[a] === boardState[c]
          ) {
            return { winner: boardState[a], combo };
          }
        }
        if (boardState.every((cell) => cell !== null)) {
          return { draw: true };
        }
        return null;
      }

      // Highlight winning cells
      function highlightWinningCells(combo) {
        combo.forEach((index) => {
          cells[index].classList.add("bg-green-300", "text-green-900", "font-extrabold");
        });
      }

      // Clear highlights
      function clearHighlights() {
        cells.forEach((cell) => {
          cell.classList.remove("bg-green-300", "text-green-900", "font-extrabold");
        });
      }

      // Render X or O image inside a cell
      function renderCell(cell, player) {
        cell.innerHTML = "";
        if (player === "X") {
          const img = document.createElement("img");
          img.src = X_IMG_URL;
          img.alt = "Logo representing X player, a stylized blue and white icon";
          cell.appendChild(img);
        } else if (player === "O") {
          const img = document.createElement("img");
          img.src = O_IMG_URL;
          img.alt = "Logo representing O player, a stylized red and white icon";
          cell.appendChild(img);
        }
      }

      // AI logic: Minimax algorithm for unbeatable AI
      function minimax(newBoard, player) {
        const availSpots = newBoard.reduce((acc, val, idx) => {
          if (val === null) acc.push(idx);
          return acc;
        }, []);

        const huPlayer = "X";
        const aiPlayer = "O";

        // Check terminal states
        const winner = getWinner(newBoard);
        if (winner === huPlayer) {
          return { score: -10 };
        } else if (winner === aiPlayer) {
          return { score: 10 };
        } else if (availSpots.length === 0) {
          return { score: 0 };
        }

        const moves = [];

        for (let i = 0; i < availSpots.length; i++) {
          const move = {};
          move.index = availSpots[i];
          newBoard[availSpots[i]] = player;

          if (player === aiPlayer) {
            const result = minimax(newBoard, huPlayer);
            move.score = result.score;
          } else {
            const result = minimax(newBoard, aiPlayer);
            move.score = result.score;
          }

          newBoard[availSpots[i]] = null;
          moves.push(move);
        }

        let bestMove;
        if (player === aiPlayer) {
          let bestScore = -Infinity;
          for (let i = 0; i < moves.length; i++) {
            if (moves[i].score > bestScore) {
              bestScore = moves[i].score;
              bestMove = i;
            }
          }
        } else {
          let bestScore = Infinity;
          for (let i = 0; i < moves.length; i++) {
            if (moves[i].score < bestScore) {
              bestScore = moves[i].score;
              bestMove = i;
            }
          }
        }

        return moves[bestMove];
      }

      // Helper to get winner for minimax
      function getWinner(board) {
        for (const combo of winningCombinations) {
          const [a, b, c] = combo;
          if (
            board[a] &&
            board[a] === board[b] &&
            board[a] === board[c]
          ) {
            return board[a];
          }
        }
        return null;
      }

      // AI move
      function aiMove() {
        if (!gameActive) return;

        // Delay AI move for better UX
        setTimeout(() => {
          const bestSpot = minimax(boardState.slice(), "O").index;
          if (bestSpot !== undefined && boardState[bestSpot] === null) {
            boardState[bestSpot] = "O";
            const cell = cells[bestSpot];
            renderCell(cell, "O");
            cell.setAttribute("aria-label", `Cell ${bestSpot + 1}, O`);
            const result = checkResult();
            if (result) {
              gameActive = false;
              if (result.winner) {
                status.textContent = `Player ${result.winner} Wins!`;
                highlightWinningCells(result.combo);
              } else if (result.draw) {
                status.textContent = "Game Draw!";
              }
              return;
            }
            currentPlayer = "X";
            updateStatus();
            cells.find((c) => c.innerHTML === "").focus();
          }
        }, 400);
      }

      // Handle cell click
      function handleCellClick(e) {
        const cell = e.target;
        const index = Number(cell.dataset.cellIndex);

        if (!gameActive || boardState[index] !== null) return;

        if (mode === "pvp") {
          boardState[index] = currentPlayer;
          renderCell(cell, currentPlayer);
          cell.setAttribute("aria-label", `Cell ${index + 1}, ${currentPlayer}`);

          const result = checkResult();

          if (result) {
            gameActive = false;
            if (result.winner) {
              status.textContent = `Player ${result.winner} Wins!`;
              highlightWinningCells(result.combo);
            } else if (result.draw) {
              status.textContent = "Game Draw!";
            }
            return;
          }

          currentPlayer = currentPlayer === "X" ? "O" : "X";
          updateStatus();
        } else if (mode === "pvc") {
          // Player is always X, robot is O
          if (currentPlayer !== "X") return; // Not player's turn

          boardState[index] = "X";
          renderCell(cell, "X");
          cell.setAttribute("aria-label", `Cell ${index + 1}, X`);

          const result = checkResult();

          if (result) {
            gameActive = false;
            if (result.winner) {
              status.textContent = `Player ${result.winner} Wins!`;
              highlightWinningCells(result.combo);
            } else if (result.draw) {
              status.textContent = "Game Draw!";
            }
            return;
          }

          currentPlayer = "O";
          updateStatus();
          aiMove();
        }
      }

      // Restart game
      function restartGame() {
        boardState.fill(null);
        cells.forEach((cell, i) => {
          cell.innerHTML = "";
          cell.setAttribute("aria-label", `Cell ${i + 1}`);
          cell.classList.remove("bg-green-300", "text-green-900", "font-extrabold");
        });
        currentPlayer = "X";
        gameActive = true;
        updateStatus();
        cells[0].focus();
      }

      // Keyboard navigation for accessibility
      function handleKeyDown(e) {
        const index = Number(e.target.dataset.cellIndex);
        if (isNaN(index)) return;

        let nextIndex;
        switch (e.key) {
          case "ArrowRight":
            nextIndex = (index + 1) % 9;
            cells[nextIndex].focus();
            e.preventDefault();
            break;
          case "ArrowLeft":
            nextIndex = (index + 8) % 9;
            cells[nextIndex].focus();
            e.preventDefault();
            break;
          case "ArrowDown":
            nextIndex = (index + 3) % 9;
            cells[nextIndex].focus();
            e.preventDefault();
            break;
          case "ArrowUp":
            nextIndex = (index + 6) % 9;
            cells[nextIndex].focus();
            e.preventDefault();
            break;
          case "Enter":
          case " ":
            e.preventDefault();
            e.target.click();
            break;
        }
      }

      // Mode change handler
      function handleModeChange() {
        mode = modeSelect.value;
        restartGame();
        if (mode === "pvc" && currentPlayer === "O") {
          aiMove();
        }
        if (mode === "pvp") {
          status.textContent = `Player Turn: ${currentPlayer}`;
        }
      }

      // Initialize
      cells.forEach((cell) => {
        cell.addEventListener("click", handleCellClick);
        cell.addEventListener("keydown", handleKeyDown);
      });
      restartBtn.addEventListener("click", restartGame);
      modeSelect.addEventListener("change", handleModeChange);

      updateStatus();
      cells[0].focus();
    })();
  </script>
</body>
</html>
